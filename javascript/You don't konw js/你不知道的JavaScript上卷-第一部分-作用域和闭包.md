# 你不知道的JavaScript上卷 - 第一部分-作用域和闭包

## 作用域是什么

### 1.1编译原理

尽管通常将JavaScript归类为“动态”或者“解释执行” 语言，但事实上它是一门编译语言。
在传统的编译语言流程中，程序中的一段源代码在执行之前会经理三个步骤，统称为"编译"

* 分词/词法分析(Tokenizing/Lexing)
* 解析/语法分析(Parsing)
* 代码生成

### 1.2理解作用域

先理解一些名词
当变量出现在赋值操作的左侧时进行LHS查询，出现在右侧时进行RHS查询。
RHS查询与简单的查找某个变量的值别无二致，而LHS查询则是视图找到变量的容器本身，从这个角度说，RHS并不是真正意义上的"赋值操作的右侧" ，更准确的说是 "非左侧"。
可以将 RHS理解成 retrieve his source value (获取到它的原值)
从概念上最好将其理解为"赋值操作的目标是谁(LHS)" 以及"谁是赋值操作的源头(RHS)"
考虑下面的程序，来理解LHS 和RHS引用 :

```js
function foo(a){
    console.log(a); //2
}
```

foo() 函数的调用需要对 foo进行RHS引用 ,意味着 "去找到foo的值 ，并把它给我" , 代码中 a=2 操作发生在2被当做参数传递给 foo() 函数时 ，2被分配给参数a ,为了给参数a(隐式地) 分配值 ，需要进行一次 LHS查询。
当然这里还有对a进行的RHS引用，并且将得到的值传递给了console.log(...) console.log(...) 本身也需要一个引用才能执行，因此会对console对象进行RHS查询，并且检测得到的值中是否有一个叫做log的方法。

小测验 (未验证 )

```js
function foo(a){
    var b =a;
    return a+b;
}
var c = foo(2);
```

1. 找到其中所有的 LHS 查询

先对c 进行 LHS 获取
这里边调用 foo 需要对 foo进行 RHS 查询

在 foo中
首先对a进行 LHS 引用
先对 b进行 LHS 引用 在对a进行 RHS 查询
在对 a 和b 各进行 RHS 查询

### 1.3 作用域嵌套

默认情况下 ，RHS和LHS会沿着嵌套层级查找变量.

### 1.4 异常

如果RHS 在所有嵌套的作用域中寻找不到所需的变量，引擎就会抛出ReferenceError异常 。
当引擎执行LHS查询时，如果在顶层(全局作用域)中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返回给引擎，前提程序运行在 "非严格模式"
接下来 ，如果RHS查找到一个变量，但是尝试对其进行不合理的操作就会抛出一个类型的异常叫做 TypeError

### 1.5小结

作用域是一套规则，用于确定在何处以及如何查找变量(标识符)。如果查找的目的是对变量进行赋值，那么就会使用LHS查询，如果目的是获取变量的值，就会使用 RHS查询。
赋值操作符会导致LHS查询。=操作符调用时传入参数的操作都会导致关联作用域的赋值操作。
JavaScript引擎首先会在代码执行前对其进行编译，在这个过程中，像var a =2 这样的是那个没那个会被分解成为两个独立的步骤:

1. 首先 var a 在其作用域中声明新变量，这会在最开始的阶段，也就是代码执行前进行。
2. 接下来，a=2 会查询 (LHS查询) 变量a并对其进行赋值。

LHS 和RHS 查询都会在当前执行作用域中开始，如果有需要(也就是说他们没有找到所需的标识符)，就会向上级作用月继续查找标识符，这样每次上升一级的作用月(一层楼)，最后抵达全局作用月(顶层)，无论找没找到都讲停止。
不成功的RHS 引用会导致抛出ReferenceError 异常。不成功的LHS 引用会导致自动隐式的创建一个全局变量(非严格模式下) ，给变量使用LHS引用的目标作为标识符，或者抛出 ReferenceError 异常(严格模式下)

## 词法作用域

作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫做"遮蔽效应" ，也可以简洁的通过对全局对象属性的引用来对其访问，就可以访问那些被同名变量遮蔽的全局变量。

### 2.2欺骗词法

如果词法作用域完全由写代码期间函数所声明的位置来定义，如何做到在运行时"修改"(也就是欺骗)
词法作用域呢？
JavaScript中有两种机制来实现这个目的。
然而社区普遍认为在代码中使用这两种截止并不是什么好主意，但是关于它们的争论通常会忽略掉重要的点:欺骗词法作用域会导致性能下降。

* 2.2.1 eval
    在执行eval(...) 之后的代码时，引擎并不知道前面的代码是以动态形式插入进来，并对词法作用域的环境进行修改。引擎只会如往常地进行词法作用域查找。
    默认情况下 ，如果eval(...)中所执行的代码包含有一个或多个声明(无论是变量还是函数)，就会对eval(...)所处的词法作用域进行修改，技术上，通过一些技巧可以间接的调用eval(...)来使其运行在全局作用域中，并对全局作用域进行修改。但无论何种情况，eval(...)都可以在运行期间修改书写期的词法作用域。
    但是在严格模式的程序中，eval(...) 在运行时有其自己的词法作用域，一位置其中的声明无法修改所在的作用域。
    在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损失。

* 2.2.2 with

with 通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。
with 可以讲一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。
注意: 尽管with块可以被一个对象处理为词法作用域，但是这个快内部正常的var声明并不会被限制在这个块的作用域中，而是被添加到with所处的函数作用域中。
(理解:这就是在讲var的变量只受方法作用域和全局作用域的约束)

eval(...) 函数如果接受了含有一个或多个声明的代码，就会修改其所在的词法作用域，而with声明实际上是根据你传递给它的对象凭空的创建了一个全新的词法作用域。

* 2.2.3 性能

由于JavaScript引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据diamante词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。
这样如果代码中大量的运用eval(...) 或with ，所有的优化可能都是无意义的，隐藏最贱的做法就是完全不做任何优化。

### 2.3 小结

词法作用域意味着作用域是由书写代码时函数声明的位置来决定的，编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它进行查找。
JavaScript中的连个机制都可以"欺骗"词法作用域: eval(...) 和with。它们的副作用就是JavaScript引擎无法对它们进行书写时的代码做静态分析，就导致不能优化代码的执行速度。

## 函数作用域和块作用域

### 3.1 函数中的作用域

函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用(事实上在嵌套的作用域也可以使用)。 这种设计方案是非常有用的，能充分的利用JavaScript变量可以根据需要改变值类型的"动态"特性。

### 3.2隐藏内部实现

实际上就是在这个代码片段的周围创建了一个作用域气泡，也就是说这段代码中的任何声明(变量和函数) 都将绑定在这个新创建的包装函数的作用域中，而不是先前这个作用域中。有很多原因促成了这种基于作用域的隐藏方法。它们大都是最小特权原则中引申出来的，也叫作最小授权或最小暴露原则，这个原则是指在软件设计中，应该最小限度的暴露必要内容，而将其他内容都"隐藏"起来
"隐藏"作用域中的变量和函数所带来的另一个好处，是可以避免通名标识符之间的冲突，两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。

1. 全局命名空间

通常一些第三方库会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间
2. 模块管理

使用模块管理器工具依赖管理器的机制将库的标识符显示地导入到另外一个特定的作用域中。

### 3.3函数作用域

了解到函数可以隐藏内部变量和函数定义，但是定义具名的函数本身也是会对全局环境有影响。
现在需要同时不污染全局环境又要能够隐藏其内部执行环境
幸好JavaScript提供了能够同时解决这两个问题的方案。

```js
(function(){
    var a =3;
    console.log(a); //3
})(); // < ---以及这一行
```

首先，明确包装函数的声明是以 (function ... 而不是 以function...开始的。尽管看上去这并不是一个很明显的细节，但是实际上却是非常重要的区别，函数会被当作函数表达式而不是一个标准的函数声明来处理。
注意: 区分函数声明和表达式最简单的方法是看function关键字出现在声明中的位置(不仅仅是一行代码，而是整个声明中的位置)。如果function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。
函数声明和函数表达式之间最重要的区别是它们名称标识符将会绑定在何处。`(function foo(){ ... })`作为函数表达式意味着foo只能在 ...所代表的位置中被访问，外部作用域则不行。foo变量名被隐藏在自身中意味着不会非必要地污染外部作用域。

* 3.3.1 匿名和具名

没有名称标识符为匿名函数
它有以下缺点:

1. 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。

2. 如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听需要解绑自身

3. 匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。

* 3.3.2 立即执行函数表达式

```js
(function(){
    //do sth
})()
```

Immediately(I) Invoked(I) Function(F) Expression(E)
相对于传统的 IIFE形式 ,很多人更喜欢另一个改进的形式:

```js
(function(){
    //.... do sth
}())
```

两种形式效果是一样的 ，IIFE的另外一种非常普遍的用法是把它们当做函数调用并传递参数进去。
另外这个模式的另外一个应用场景是可以解决undefined标识符的默认值被错误的覆盖导致的异常
(虽然不常见)。将一个参数命名为undefined，但是在对应的位置不传入任何值，这样就可以保证在代码块中undefined标识符的值真是undefined:

```js
undefined =true; // 给其他代码挖了一个大坑! 绝对不要这么做
(function IIFE(undefined){
    var a ;
    if(a ===undefined){
        console.log("Undefiend is safe here");
    }
})()
```

备注: 亲自试验了一下得知 在IE9以下版本的浏览器确实修改了undefined的值，但是chrome和IE9以上的版本都没法修改undefined
IIFE还有一种变化的用途是倒置代码运行顺序，将需要运行的函数放在第二位，在IIFE执行之后当做参数传递进去。这种模式在UMD(Universal Module Definition) 项目中被广泛的使用。尽管这种模式略显冗长。

```js
var a =2;
(function IIFE(def){
    def(window);
})(function def(global){
    var a =3;
    console.log(a);  //3
    console.log(global.a); //2
})
```

### 3.4 块级作用域

* 3.4.1 with

用 with从对象中创建出的作用域仅在with声明中而非外部作用域中有效

* 3.4.2 try/catch

JavaScript ES3中规定 try/catch 的catch分句会创建一个块级的作用域，其中声明的变量仅在catch内部有效。

* 3.4.3 let

众所周知，JavaScript在暴露块作用域的功能中有一些奇怪的行为，幸好ES6改变了现状，let关键字可以将变量绑定到所在的任意作用域中(通常是{...}) 内部。
在使用 let进行声明不会在块作用域中进行变量提升。声明的代码被运行之前，声明并不"存在"。

```js
{
    console.log(bar ); //ReferenceError !
    let bar =2;
}
```

1. 垃圾收集

另一个块作用域非常有用的原因和闭包以及回收内存垃圾的回收机制相关。这里简要说明，内部原理在第五章详细介绍。
2. let循环

讨论let的经典例子就是和var的比较，由于var仅会在方法块和全局范围内，因此循环有的时候会共享var变量的状态，导致不可预测的执行结果，let就可以避免掉
let循环执行表现类似:

```js
{
    let j;
    for(j=0;j<10;j++){
        let i = j; //每个迭代重新绑定
        console.log(i);
    }
}
```

for循环中 let 形成了自己的块级作用域，这样就不会出现var变量的情况。

* 3.4.4 const

除了 let以外，ES6引入了const ,同样可以创建块作用域变量，但是其值(常量)是固定的，只有任何视图修改值的操作都会引起错误。

### 3.5 小结

函数JavaScript中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中"隐藏" 起来，这是有意为之的良好软件的设计原则。
有些人认为块级作用域不应该完全作为函数作用域的替代方案。两种功能应该同时存在，开发者可以并且也应该根据需要选择使用何种作用域，创造可读、可维护的优良代码。

## 提升

### 4.1 先有鸡还是先有蛋

考虑这两段代码

```js
a =2;
var a;
console.log(a);  //2
```

```js
console.log(a); //undefined
var a =2;
```

### 4.2 编译器再度来袭

对于上边代码中，var a 会被提升到最开始
第二段代码中，`var a =2;`会被拆分为 `var a;`  ,`a=2`
所以像第一段代码那样 ，`var a`会被提升，而 `a=2`不会提升，导致结果为undefined

### 4.3 函数优先

函数声明和变量声明都会被提升。但是一个值得注意的细节(这个细节可以出现在有多个"重复"声明的代码中) 是函数会首先被提升，然后才是变量。
考虑以下代码:

```js
foo(); //1
var foo;
function foo(){
    console.log(1);
}
foo = function(){
    console.log(2);
}
```

结果会是1 而不是2 这个代码片段会被引擎理解如下形式:

```js
function foo(){
     console.log(1);
}
foo(); //1
foo = function(){
    console.log(2);
}
```

```js
foo();
var a = true;
if(a){
    function foo(){
        console.log("a");
    }
}else{
  function foo(){
      console.log("b");
  }
}
```

上边的代码，经测试 发现在 edge浏览器以下的ie版本 均显示 b
而edge和 chrome下都报错 foo 不是一个方法,输出undefined

### 4.4 小结

我们认为习惯性的将 `var a = 2`看作一个声明，而实际上JavaScript引擎并不这么认为。它会将`var a` 和 `a = 2`当作两个独立的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。
这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。它可以将这个过程形象地想象成所有的声明(变量和函数) 都会被"移动" 到各自作用域的最顶端，这个过程被称为提升。
声明本省会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。
要注意避免重复声明，特别是当普通的var声明和函数声明混合在一起的时候，否则会引起很多危险的问题!

## 作用域闭包

### 5.1 启示

对于有一点JavaScript使用经验但从未真正理解闭包概念的人来说，理解闭包可以看作是某种意义上的重生 :stuck_out_tongue_winking_eye: ，但是需要付出非常多的努力和牺牲才能理解值个概念。
:sweat::sweat:
秘诀是: JavaScript中闭包无处不在，你只需要能够识别并拥抱它
闭包是基于词法作用域书写代码时所产生的自然结果，甚至不需要为了利用它们而有意识的创建闭包。闭包的创建和使用在你的代码中随处可见。你缺少的是你根据你自己的意愿来识别、拥抱和影响闭包的思维环境。

### 5.2 实质问题

当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。
下面的一些代码解释这个定义:

```js
function foo(){
    var a =2;
    function bar(){
        console.log(a);  //2
    }
    bar();
}
foo();
```

这段代码看起来和嵌套作用域中的示例代码很相似。基于词法作用域的查找规则，函数bar()可以访问外部作用域中的变量a(这是一个RHS引用查询)。
这是闭包吗？
技术上讲，`也许是`。但是根据前面的定义，`确切的说并不是`。我认为最准确地用来解释bar()对a的引用的方法是词法作用域的查找规则，而这些规则只是闭包的一部分(但却是非常重要的一部分)。
从纯学术的角度说，在上面的代码片段中，函数bar() 具有一个涵盖foo()作用域的闭包(事实上，涵盖了它能访问的所有作用域，比如全局作用域)。也可以认为bar()被封闭在了foo()的作用域中。因为bar()嵌套在foo()内部。

```js
function(){
    var a =2;
    function bar(){
        console.log(a);
    }
    return bar;
}
var baz =foo();
baz();  //2
```

bar()依然持有对该作用域的引用，这个引用就叫做闭包。
通常讲的 IIFE 自执行函数，`严格来讲并不是闭包，因为函数并不是在它本身的词法作用域以外执行的`。它在定义时所在的作用域中执行(而外部作用域，也就是全局作用域也持有a)。a是通过普通的词法作用域查找而非闭包发现的。
尽管IIFE本身并不是观察闭包的恰当例子，但它的确创建了闭包，并且也是最常用来创建可以被封闭起来的闭包工具。因此IIFE的确同闭包息息相关，即使本身并不会真的使用闭包。

### 5.4 循环和闭包

var 在for循环中的类似例子

```js
for(var i=1;i<=5;i++){
    setTimeout(function timer(){
        console.log(i);
    },i*1000)
}
```

这段代码在运行时会以每秒一次的频率输出五次6。
缺陷是我们试图假设循环中的每个迭代在运行时都会给自己 "捕获" 一个 i的副本。但是根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封装在一个共享的全局作用域中，因此实际上只有一个i。
可以用 IIFE来创建作用域。
看下面代码:

```javascript
for(var i=1;i<=5;i++){
    (function(){
        setTimeout(function timer(){
            console.log(i);
        }, i*1000)
    })();
}
```

这段代码实际上也是不行的，但是作用域是空的，仅仅将它们进行封装是不够的。需要我们为它添加一点实质内容才行。

```js
for(var i=1;i<=5;i++){
    (function(){
        var j =i;
        setTimeout(function timer(
            console.log(j);
        ){},j * 1000)
    })()
}
```

这样就正常了，可以在精简一些:

```js
for(var i=1;i<=5;i++){
    (function(j){
        setTimeout(function timer(
            console.log(j);
        ){},j * 1000)
    })(i)
}
```

#### 重返块作用域

let声明可以用来劫持块作用域，并且在这个块作用域中声明一个变量。

```js
for(var i=1;i<=5;i++){
    let j =i; //闭包的块作用域
    setTimeout(function timer(){
        console.log(j);
    }, j*1000);
}
```

这段代码可以正常显示，但是 for循环头部的let声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每次迭代都会使用上一个迭代结束时的值来初始化这个变量。
所以下边的代码:

```js
for(let i=1;i<=5;i++){
    setTimeout(function timer(){
        console.log(i);
    },i * 1000);
}
```

### 5.5 模块

模块模式需要具备两个必要条件。

1. 必须有外部的封闭函数，该函数必须至少被调用一次(每次调用都会创建一个新的模块实例)。
2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。

一个具有函数属性的对象本身并不是真正的模块。从方便观察的角度看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。

#### 5.5.1 现代的模块机制

#### 5.5.2 未来的模块机制

ES6中为模块增加了一级语法支持。但通过模块系统进行加载时，ES6会将文件当作独立的模块来处理。

## 附录A 动态作用域

动态作用域暗示有很好的理由让作用域作为一个在运行时就被动态确定的形式，而不是在写代码是进行静态确定的形式，事实上也是这样的。看下边的代码:

```js
function foo(){
    console.log(a); // 2
}
function bar(){
    var a =3;
    foo();
}
var a =2;
bar();
```

词法作用域让foo()中的 a通过RHS引用到了全局作用域中的a，因此会输出2。
而动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，作用域链基于调用栈的，而不是代码中的作用域嵌套。
因此 如果JavaScript 具有动态作用域，理论上代码会输出 3 而不是2。
但这其实是因为你可能只写过基于词法作用域的代码(或者至少以词法作用域为基础进行了深入的思考) ,因此对动态作用域感到陌生。如果你只用基于动态作用域的语言写过代码，就会觉的这是很自然的，而词法作用域看上去才奇怪。
需要明确的是，`事实上JavaScript并不具有动态作用域。它只有词法作用域`。简单明了。但是this 机制某种程度上很像动态作用域。
主要区别: 词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。(this也是!) 词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。
最后，this 关注函数如何调用，这就表明了this机制和动态作用域之间的关系多么紧密。

## 附录B 块作用域的替代方案

在深入研究了块级作用域之后。至少从ES3发布以来，JavaScript中就有了块级作用域，而with和catch分句就是块级作用域的两个小例子。
随着ES6中引入let，代码终于有了创建完整、不受约束的块级作用域的能力。
块级作用域在功能上和代码风格上都拥有很多不错的新特性。

```js
{
    let a =2;
    console.log(a); //2
}
console.log(a); // ReferenceError
```

这段代码在ES6中可以正常工作，但是在 ES6之前可以用 catch 来实现(虽然不是美观)

```js
try{throw 2;}catch(a){
    console.log(a);  //2
}
console.log(a)   //ReferenceError
```

这里强制抛出错误，但是抛出错误就是一个值2，然而catch 会接受到这个值。

### B.1 Traceur

Google 维护的一个名为 Traceur 的项目，该项目正式用来将ES6代码转换成兼容ES6之前的环境。

### B.2 隐式和显式作用域

第三章中介绍作用域时，我们的代码有一些可维护性和可扩展性方面的缺陷。有没有其他可以使用块级作用域，并且还能避免这种缺陷的途径?
考虑下面这种let的使用方法，它被称作let作用域或let声明(对比前面的let定义)。

```js
let(a =2 ){
    console.log(a); //2
}
console.log(a); // ReferenceError
```

同隐式的劫持一个已经存在的作用域不同，let声明会创建一个显示的作用域并与其进行绑定。显式作用域不仅更加突出，在diamante重构时也表现得更加健壮。在语法上，通过强制性地将所有变量声明提升到块的顶部来产生更简洁的代码。这样更容易判断变量是否属于某个作用域。
这种模式同很多人在函数作用域中手动将var声明提升到函数顶部的方式很接近。let声明有意将变量声明放到块的顶部，如果你并没有到处使用let定义，那么你的作用域就很容易辨识和维护。
但是这里有一个小问题，let声明并不包含在ES6中。官方的Tranceur 编译器也不接受这种形式的代码。
我们有两个选择，使用合法的ES6语法并且在代码规范性上做一些妥协。

```js
/*let*/{ let a =2;
console.log(a);
}
console.log(a) // ReferenceError
```

### B.3 性能

首先，try/catch 的性能的确很糟糕，但技术层面上没有合理的留来说明try/catch 必须这么慢，或者会一直慢下去。

其次，IIFE和try/catch 并不是完全等价的，因为如果将一段代码中的任意一部分拿出来用函数进行包裹，会改变该段代码的含义，其中this,return ,break,continue 都会发生变化。IIFE并不是一个普适的解决方案，它只适合在某些情况下进行手动操作。
最后的问题变成了: 你是否想要块级作用域?如果你想要，可以使用弓箭帮助你，如果不想要，继续使用var来写代码就好了。

## 附录C this 词法

简单的来说，箭头函数在涉及`this`绑定时的行为和普通函数的行为完全不一致。它放弃了所有普通`this`绑定规则，取而代之的是用当前的词法作用域覆盖了this本来的值。
因此，这个代码片段中的箭头函数并非是以某种不可预测的方式同所属的this进行了解绑定，而只是"继承"了cool()函数的`this` 绑定(因此调用它不会出现错误)。
